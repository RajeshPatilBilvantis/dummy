-- FINAL GOLD STANDARD VERSION - REFACTORED WITH SELF-JOIN
-- This version uses a robust self-join pattern on a single ranked list of policies,
-- which guarantees consistency and correctly handles clients with only one policy.

WITH
-- Step 1: Create a clean, deduplicated list of policies with valid product names.
DistinctPolicies AS (
    SELECT DISTINCT
        axa_party_id, policy_no, wti_lob_txt, register_date, isrd_brth_date,
        acct_val_amt, face_amt, cash_val_amt
    FROM wealth_management_client_metrics
    WHERE axa_party_id IS NOT NULL AND policy_no IS NOT NULL AND register_date IS NOT NULL AND wti_lob_txt IS NOT NULL
),

-- Step 2: Rank all unique policies for each client just ONCE. This is our master timeline.
RankedPolicies AS (
    SELECT *,
           ROW_NUMBER() OVER(PARTITION BY axa_party_id ORDER BY register_date ASC, policy_no ASC) as policy_rank
    FROM DistinctPolicies
),

-- (Other CTEs for static/summary info remain useful)
AgentLatestSnapshot AS (
    SELECT *, ROW_NUMBER() OVER(PARTITION BY agent_code ORDER BY yearmo DESC) as rn
    FROM wealth_management_rpt_agents
),
ClientActivityMetrics AS (
    SELECT account_axa_party_id_c AS client_id, COUNT(task_id) AS total_activities_last_12m
    FROM wealth_management_activities
    WHERE activity_date >= ADD_MONTHS(CURRENT_DATE, -12)
    GROUP BY account_axa_party_id_c
),
LatestRetentionSnapshot AS (
    SELECT *, ROW_NUMBER() OVER(PARTITION BY axa_party_id ORDER BY business_month DESC) as rn
    FROM wealth_management_pcpg_retention
)

-- Final SELECT: Assembling the complete feature set using the robust self-join pattern.
SELECT
    -- ===== Primary Key =====
    p1.axa_party_id,

    -- ===== Static Client Features (Current state is acceptable) =====
    DATEDIFF(CURRENT_DATE, p1.isrd_brth_date) / 365.25 AS current_client_age,
    ret.client_age_band,
    ret.city AS client_city,
    ret.state AS client_state,
    ret.client_segment,
    ret.client_tenure,
    ret.client_type,
    ret.aum_sum AS total_aum_with_us_today,
    ret.aum_band,

    -- ===== Point-in-Time Features (from the first policy, alias 'p1') =====
    p1.wti_lob_txt AS initial_product_purchased,
    p1.isrd_brth_date AS client_birth_date,
    p1.register_date AS first_purchase_date,
    p1.policy_no AS first_policy_no, -- Your debugging column
    p1.acct_val_amt AS first_policy_acct_val,
    p1.face_amt AS first_policy_face_amt,
    p1.cash_val_amt AS first_policy_cash_val,
    
    -- ===== Engagement and Agent Features (Current state is acceptable) =====
    COALESCE(act.total_activities_last_12m, 0) AS total_activities_last_12m,
    ret.agent_code,
    agent.rpt_lgth_of_svc AS agent_length_of_service,
    agent.rank_desc AS agent_rank,
    agent.ppg_membership AS agent_is_ppg_member,

    -- ===== Target Variable and Related Features (from the second policy, alias 'p2') =====
    p2.wti_lob_txt AS next_product_purchased, -- This will now correctly be NULL if no 2nd policy exists.
    p2.register_date AS second_purchase_date, -- Also NULL for single-policy clients.
    p2.policy_no AS second_policy_no, -- Also NULL for single-policy clients.
    MONTHS_BETWEEN(p2.register_date, p1.register_date) AS months_to_second_purchase,
    DATEDIFF(p2.register_date, p1.isrd_brth_date) / 365.25 AS age_at_second_purchase

FROM
    -- Our base is now the list of FIRST policies.
    RankedPolicies AS p1
-- We LEFT JOIN this list to the SECOND policies from the SAME ranked table.
LEFT JOIN RankedPolicies AS p2
    ON p1.axa_party_id = p2.axa_party_id AND p2.policy_rank = 2
-- Now, we join all the other summary information to our base of first-policy holders.
LEFT JOIN LatestRetentionSnapshot AS ret
    ON p1.axa_party_id = ret.axa_party_id
LEFT JOIN AgentLatestSnapshot AS agent
    ON ret.agent_code = agent.agent_code AND agent.rn = 1
LEFT JOIN ClientActivityMetrics AS act
    ON p1.axa_party_id = act.client_id
WHERE
    -- This condition ensures our base only contains the clients' FIRST policies.
    p1.policy_rank = 1
    -- This condition ensures we only get the most recent snapshot from the retention table.
    AND (ret.rn = 1 OR ret.rn IS NULL); -- Use IS NULL to keep clients who might not be in the retention table.

DistinctPolicies --- To solve the first big duplication problem (31 rows of each axa_party_id with different client_tenure and aum_sum), we need a clean, master list of every unique policy a client has. So, from wealth_management_client_metrics table, we took the rows with DISTINCT axa_party_id (essentially, unique client id).

ClientProductPortfolio --- To count how many policies of each specific type a client owns, we took the clean DistinctPolicies and grouped all teh policies by client and for each client, we used COUNT(CASE WHEN ...) as a counter.

InitialProduct --- To find the very first product each client ever bought, we took DistinctPolicies and used ROW_NUMBER() to rank teh policies for a particular client and ordered by the register_date in ASC order. We select the 1st one as teh initial product.

NextProductTarget --- To find the second product each client ever bought, which will be the answer our model tries to predict (target), we take DistinctPolicies and do that same as getting the initial product but, take the 2nd one.

AgentLatestSnapshot --- To get only the most recent, up-to-date information for every agent, we use the wealth_management_rpt_agents table.  It groups all the monthly records using ROW_NUMBER() for an agent and orders them from newest to oldest (ORDER BY yearmo DESC) - newest record gets no.1 .

ClientActivityMetrics & ClientPolicySummary --- To create simple summaries for each client, used wealth_management_activities and wealth_management_client_metrics. Used GROUP BY to collapse all rows for a single client into one summary row, calculating their total activities in the last year, their average age, and their estimated total wealth.

LatestRetentionSnapshot --- To solve the second duplication problem, we take only the most recent summary record for each client from the wealth_management_pcpg_retention table. As retention table is also a monthly snapshot, so it ranks all the rows for each client by the business_month (newest first) and gives the most recent record the number 1. 

FROM LatestRetentionSnapshot AS ret, we start our assembly using the clean, one-row-per-client list. every other cte will be attached to this.
Then, for each client in our list, we perform a lookup to get the prepared components.
LEFT JOIN ClientPolicySummary ...: We look up and attach the client's age and wealth.
LEFT JOIN AgentLatestSnapshot ...: We look up the agent's info. The AND agent.rn = 1 is where we tell the assembly line to only use the component that was ranked #1 (the newest one), etc.
WHERE Clause --- ret.axa_party_id IS NOT NULL: A simple check to make sure the client ID is valid.
AND ret.rn = 1 --- It tells the query to only keep the final assembled rows where the record from the retention table was the most recent one (ranked #1). This is what guarantees only one row per client in final output data.
